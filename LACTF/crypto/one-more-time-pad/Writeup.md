chall.py will be referenced within the writeup and is provided within CTF-Writeups/LACTF/crypto/one-more-time-pad/chall.py

## Challenge Description 
I heard the onetime pad is perfectly secure so I used it to send an important message to a friend, but now a UCLA competition is asking for the key? I threw that out a long time ago! Can you help me recover it?
chall.py is provided

## Difficulty
486 solves / 154 points

## Solution

### Analysis
chall.py declares a variable pt that is a byte string of "Long ago, the four nations lived together in harmony ...". It then calls `key = cycle(b"lactf{??????????????}")` which I looked up. I found [Geeks for Geeks](https://www.geeksforgeeks.org/python-itertools-cycle/) which told me it converted the byte string of the flag which remained undefined. ct is then defined as the empty string

At this point I began an analysis of the for loop
```
for i in range(len(pt)):
    b = (pt[i] ^ next(key))
    ct += f'{b:02x}'
print("ct =", ct)
```
The loop goes through pt, and sets b equal to the XOR of the character at element i in pt and the next item in key (which I found through [W3Schools](https://www.w3schools.com/python/ref_func_next.asp).) Afterwards `{b:02x}` turns b into a 2 digit hexadecimal number which is then converted by `f` into a string literal and appended to ct. 

This gives us how ct is calculated, and right underneath the loop in the comment, we get a given ct which clearly is the ct generated by the actual flag.

To get the flag, I simply had to reverse the calculations. Since all of the calculations were done on a byte string, I first converted the given ct into a byte string using `bytes.fromhex()`. Then I needed to undo the XOR calculation which can actually be done by using the XOR operator again on the product of the original XOR and one of the operands to yield the other operand used. This means that if one were to XOR the byte string of ct with the operand `pt[i]`  that will be the second operand which is `next(key)` which is a small piece of our flag. At that point our flag is still in the byte string form and needs to be decoded since it was dececlared as `b"lactf{??????????????}"`. Therefore we need to decode it, but we need to know what encoding the `b` prefix uses. The b prefix requires ascii, I tried to decode it using ascii which proved fruitful. The final conversion code ended up being as follows which didn't give me a clean version of the flag but I could extract the flag from it.
```
final = ""
ct = "200e0d13461a055b4e592b0054543902462d1000042b045f1c407f18581b56194c150c13030f0a5110593606111c3e1f5e305e174571431e"
b = bytes.fromhex(ct)
for i in range(len(b)):
    prething = b[i]
    thing = prething ^ pt[i]
    final += bytes.fromhex(thing).decode('ascii')
print ("final =", final)
```
